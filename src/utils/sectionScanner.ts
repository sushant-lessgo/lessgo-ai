/**
 * Section Scanner Utility
 * Analyzes page sections to auto-configure navigation
 */

import type { EditStore } from '@/types/store';

export interface NavigationItem {
  id: string;
  label: string;
  link: string;
  sectionId?: string;
  isAutoGenerated: boolean;
  order: number;
}

export interface SectionInfo {
  id: string;
  type: string;
  layout: string;
  label?: string;
  priority: number;
}

// Priority sections that should appear in navigation
const SECTION_PRIORITIES: Record<string, { label: string; priority: number }> = {
  // Primary sections
  features: { label: 'Features', priority: 1 },
  pricing: { label: 'Pricing', priority: 2 },
  testimonials: { label: 'Reviews', priority: 3 },
  faq: { label: 'FAQ', priority: 4 },
  
  // Secondary sections
  problem: { label: 'Solution', priority: 5 },
  results: { label: 'Results', priority: 6 },
  comparison: { label: 'Compare', priority: 7 },
  howitworks: { label: 'How It Works', priority: 8 },
  usecase: { label: 'Use Cases', priority: 9 },
  integration: { label: 'Integrations', priority: 10 },
  security: { label: 'Security', priority: 11 },
  objection: { label: 'Benefits', priority: 12 },
  
  // Tertiary sections
  socialproof: { label: 'Social Proof', priority: 13 },
  beforeafter: { label: 'Before & After', priority: 14 },
  uniquemechanism: { label: 'Technology', priority: 15 },
  foundernote: { label: 'About', priority: 16 },
  
  // Call to action sections
  close: { label: 'Get Started', priority: 17 },
  primarycta: { label: 'Start Now', priority: 18 },
};

// Layout name to section type mapping
const LAYOUT_TO_SECTION_TYPE: Record<string, string> = {
  // Features layouts
  IconGrid: 'features',
  SplitAlternating: 'features',
  Tabbed: 'features',
  Timeline: 'features',
  FeatureTestimonial: 'features',
  MetricTiles: 'features',
  MiniCards: 'features',
  Carousel: 'features',
  
  // Pricing layouts
  TierCards: 'pricing',
  ToggleableMonthlyYearly: 'pricing',
  FeatureMatrix: 'pricing',
  SegmentBasedPricing: 'pricing',
  SliderPricing: 'pricing',
  CallToQuotePlan: 'pricing',
  CardWithTestimonial: 'pricing',
  MiniStackedCards: 'pricing',
  
  // Testimonials layouts
  QuoteGrid: 'testimonials',
  VideoTestimonials: 'testimonials',
  AvatarCarousel: 'testimonials',
  BeforeAfterQuote: 'testimonials',
  SegmentedTestimonials: 'testimonials',
  RatingCards: 'testimonials',
  PullQuoteStack: 'testimonials',
  InteractiveTestimonialMap: 'testimonials',
  
  // FAQ layouts
  AccordionFAQ: 'faq',
  TwoColumnFAQ: 'faq',
  InlineQnAList: 'faq',
  SegmentedFAQTabs: 'faq',
  QuoteStyleAnswers: 'faq',
  IconWithAnswers: 'faq',
  TestimonialFAQs: 'faq',
  ChatBubbleFAQ: 'faq',
  
  // How It Works layouts
  AccordionSteps: 'howitworks',
  AnimatedProcessLine: 'howitworks',
  CardFlipSteps: 'howitworks',
  IconCircleSteps: 'howitworks',
  ThreeStepHorizontal: 'howitworks',
  VerticalTimeline: 'howitworks',
  VideoWalkthrough: 'howitworks',
  ZigzagImageSteps: 'howitworks',
  
  // Other section types follow similar pattern...
};

/**
 * Extract section type from section ID or layout
 */
function extractSectionType(sectionId: string, layout: string): string {
  // First try to get from layout name
  const typeFromLayout = LAYOUT_TO_SECTION_TYPE[layout];
  if (typeFromLayout) return typeFromLayout;
  
  // Try to extract from section ID (e.g., "features-123456-abc" -> "features")
  const idParts = sectionId.toLowerCase().split('-');
  if (idParts.length > 0) {
    const possibleType = idParts[0];
    if (SECTION_PRIORITIES[possibleType]) {
      return possibleType;
    }
  }
  
  // Try to match section ID with known types
  for (const sectionType of Object.keys(SECTION_PRIORITIES)) {
    if (sectionId.toLowerCase().includes(sectionType)) {
      return sectionType;
    }
  }
  
  return 'custom';
}

/**
 * Scan sections and generate navigation items
 */
export function scanSectionsForNavigation(
  sections: string[],
  sectionLayouts: Record<string, string>,
  content: Record<string, any>,
  maxItems: number = 5
): NavigationItem[] {
  console.log('ðŸ§­ [NAV-DEBUG] Scanning sections...', {
    sectionsCount: sections.length,
    sections: sections,
    layouts: sectionLayouts,
    maxItems
  });

  const sectionInfos: SectionInfo[] = [];
  
  // Analyze each section
  for (const sectionId of sections) {
    // Skip header and footer sections
    if (sectionId.includes('header') || sectionId.includes('footer')) {
      console.log('ðŸ§­ [NAV-DEBUG] Skipping header/footer section:', sectionId);
      continue;
    }
    
    const layout = sectionLayouts[sectionId] || '';
    const sectionType = extractSectionType(sectionId, layout);
    
    console.log('ðŸ§­ [NAV-DEBUG] Analyzing section:', {
      sectionId,
      layout,
      sectionType,
      hasContent: !!content[sectionId]
    });
    
    if (sectionType !== 'custom') {
      const priorityInfo = SECTION_PRIORITIES[sectionType];
      if (priorityInfo) {
        // Check if this section type already exists
        const existingSection = sectionInfos.find(s => s.type === sectionType);
        if (!existingSection) {
          console.log('ðŸ§­ [NAV-DEBUG] Adding section to navigation:', {
            sectionId,
            sectionType,
            label: priorityInfo.label,
            priority: priorityInfo.priority
          });
          
          sectionInfos.push({
            id: sectionId,
            type: sectionType,
            layout,
            label: priorityInfo.label,
            priority: priorityInfo.priority,
          });
        } else {
          console.log('ðŸ§­ [NAV-DEBUG] Section type already exists, skipping:', sectionType);
        }
      } else {
        console.log('ðŸ§­ [NAV-DEBUG] No priority info found for section type:', sectionType);
      }
    } else {
      console.log('ðŸ§­ [NAV-DEBUG] Custom section, skipping:', sectionId);
    }
  }
  
  console.log('ðŸ§­ [NAV-DEBUG] Found section infos:', sectionInfos);
  
  // Sort by priority and take top N items
  sectionInfos.sort((a, b) => a.priority - b.priority);
  const topSections = sectionInfos.slice(0, maxItems);
  
  console.log('ðŸ§­ [NAV-DEBUG] Top sections after sorting:', topSections);
  
  // Convert to navigation items
  const navItems = topSections.map((section, index) => ({
    id: `nav-${section.id}`,
    label: section.label || 'Section',
    link: `#${section.id}`,
    sectionId: section.id,
    isAutoGenerated: true,
    order: index,
  }));
  
  console.log('ðŸ§­ [NAV-DEBUG] Final navigation items:', navItems);
  
  return navItems;
}

/**
 * Get max navigation items for header variant
 */
export function getMaxNavItemsForHeader(headerLayout: string): number {
  const maxItemsMap: Record<string, number> = {
    MinimalNavHeader: 4,
    NavWithCTAHeader: 6,  // Updated from 4 to 6 (no CTA anymore)
    CenteredLogoHeader: 6,
    FullNavHeader: 7,  // Updated from 5 to 7 (no CTAs anymore)
  };
  
  return maxItemsMap[headerLayout] || 4;
}

/**
 * Generate default navigation label from section type
 */
export function getDefaultNavLabel(sectionType: string): string {
  const priorityInfo = SECTION_PRIORITIES[sectionType];
  return priorityInfo?.label || sectionType.charAt(0).toUpperCase() + sectionType.slice(1);
}

/**
 * Initialize navigation for the first time
 */
export function initializeNavigation(state: EditStore): NavigationItem[] {
  console.log('ðŸ§­ [NAV-DEBUG] Initializing navigation...', {
    sections: state.sections,
    sectionLayouts: state.sectionLayouts,
    hasContent: !!state.content
  });

  // Find header section and its layout
  const headerSection = state.sections.find(id => id.includes('header'));
  if (!headerSection) {
    console.log('ðŸ§­ [NAV-DEBUG] No header section found, using default');
    return [];
  }
  
  const headerLayout = state.sectionLayouts[headerSection] || 'MinimalNavHeader';
  const maxItems = getMaxNavItemsForHeader(headerLayout);
  
  console.log('ðŸ§­ [NAV-DEBUG] Header config:', {
    headerSection,
    headerLayout,
    maxItems
  });
  
  // Scan sections and generate navigation
  const navItems = scanSectionsForNavigation(
    state.sections,
    state.sectionLayouts,
    state.content,
    maxItems
  );
  
  console.log('ðŸ§­ [NAV-DEBUG] Generated navigation items:', navItems);
  
  return navItems;
}

/**
 * Update navigation when sections change
 */
export function updateNavigationForSectionChanges(
  currentNav: NavigationItem[],
  sections: string[],
  sectionLayouts: Record<string, string>
): NavigationItem[] {
  // Keep user-added items
  const userItems = currentNav.filter(item => !item.isAutoGenerated);
  
  // Check if auto-generated items' sections still exist
  const validAutoItems = currentNav.filter(item => {
    if (!item.isAutoGenerated) return false;
    if (!item.sectionId) return true; // External link
    return sections.includes(item.sectionId);
  });
  
  // Combine and reorder
  const allItems = [...validAutoItems, ...userItems];
  allItems.sort((a, b) => a.order - b.order);
  
  return allItems;
}